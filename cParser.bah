#import "iostream.bah"
#import "string.bah"
#import "time.bah"
#import "jit.bah"

#import "compiler/lexer.bah"

#import "cSymbols.bah"

onlyWarnings = false

const unusedCattributes = []str{
    "__attribute__", "__asm__", "__access__"
}

const warningMessage = "\033[1;31m[Warning]\033[0m "
const infoMessage = "\033[2m[Info]\033[0m "

struct cToken extend bahToken {
    realLine: uint
    realFile: str
    shouldOutput: bool

    getPos() str {
        #debug {
            return "\033[32m"+this.realFile+":"+uintToStr(this.realLine)+"\033[0m [processed file line: "+uintToStr(this.line)+"]"
        }

        #debug! {
            return "\033[32m"+this.realFile+":"+uintToStr(this.realLine)+"\033[0m"
        }
    }


    getCLoc() cLoc {
        return cLoc {this.realFile, this.realLine}
    }
}

#define parseCStruct(tokens []cToken, start uint) [cType*, uint]
#define parseCEnum(tokens []cToken, start uint) [cEnum*, uint]
#define consumeCType(tokens []cToken, start uint) [cType*, str, uint]

collapseCvalue(tokens []cToken, start uint) [int, uint] {
    if tokens[start].type != TOKEN_TYPE_INT || tokens[start+1].type == TOKEN_TYPE_SYNTAX {
        nbEnclavers = 0
        calcStr = rope("")
        i=start; for i < len(tokens), i++ {
            if tokens[i].cont == "(" || tokens[i].cont == "[" || tokens[i].cont == "{" {
                if i+1 < len(tokens) && tokens[i+1].type == TOKEN_TYPE_VAR {
                    i += 2
                    continue
                }
                nbEnclavers++
            } else if tokens[i].cont == ")" || tokens[i].cont == "]" || tokens[i].cont == "}" {
                nbEnclavers--
                if nbEnclavers < 0 {
                    break
                }
            } else if tokens[i].cont == ";" {
                break
            } else if tokens[i].cont == "sizeof" {
                tpCons = consumeCType(tokens, i+2)
                calcStr += rope(uintToStr(tpCons[0].getSize()))
                i = tpCons[2]
                continue
            }

            calcStr += rope(tokens[i].cont)
        }

        fcalcStr = calcStr.toStr()

        if len(fcalcStr) != 0 {
            if onlyWarnings == false {
                print(infoMessage+"Calculating: \033[35m"+fcalcStr+"\033[0m using JIT compiler (at: "+tokens[i].getPos()+") -> ")
            }
            startTime = getTimeUnix()

            jitObj = jitCompileNoBuiltin("calc() int {
                return "+fcalcStr+"
            }")

            calcFn = <function()uint>jitObj.getSymbol("calc")
            
            nb = calcFn()

            if onlyWarnings == false {
                println("\033[35m"+intToStr(nb)+"\033[0m (took "+uintToStr((getTimeUnix() - startTime) / 1000000)+"ms)")
            }

            return [nb, i]
        }
    }
    return [strToInt(tokens[start].cont), start+1]
}

consumeCType(tokens []cToken, start uint) [cType*, str, uint] {
    tp = new cType {
        loc: tokens[start].getCLoc()
    }
    i = start
    name = ""

    for i < len(tokens), i++ {

        if tokens[i].cont == "const" || tokens[i].cont == "signed" || tokens[i].cont == "static" || tokens[i].cont == "inline" {
            continue
        }

        if tokens[i].cont == "unsigned" {
            tp.isUnsigned = true
            continue
        }

        if tokens[i].cont == "long" {
            tp.isLong = true
            continue
        }

        if tokens[i].cont == "short" {
            tp.isShort = true
            continue
        }

        if tokens[i].cont == "__inline" || tokens[i].cont == "volatile" || tokens[i].cont == "extern" || tokens[i].cont == "__extension__" {
            continue
        }

        if tokens[i].cont in unusedCattributes {
            nbPar = 0
            i++
            for i < len(tokens), i++ {
                if tokens[i].cont == "(" {
                    nbPar++
                } else if tokens[i].cont == ")" {
                    nbPar--
                    if nbPar == 0 {
                        break
                    }
                }
            }
            continue
        }

        break
    }


    if tokens[i].cont == "(" && tokens[i+1].cont == "*" && tokens[i+3].cont == ")" {
        i += 4
        name = tokens[i-2].cont
        tp.type = cTypeFunc
        currTp = tp
        for i < len(tokens), i++ {
            if tokens[i].cont != "(" && tokens[i].cont != "," {
                break
            }
            i++

            if tokens[i].cont == ")" {
                break
            }

            argTpCons = consumeCType(tokens, i)
            currTp.next = new cType {
                name: argTpCons[1]
                child: argTpCons[0]
                loc: tokens[i].getCLoc()
            }
            i = argTpCons[2] - 1
            currTp = currTp.next
        }
        i++
    } else {

        if tokens[i].cont == "__typeof__" {
            tp.name = "void"
            tp.type = cTypePrim
            tp = tp.getPtr()
            i += 3
        } else if tokens[i].cont in cPrimitiveTypes {
            tp.type = cTypePrim
            tp.name = tokens[i].cont
        } else if tokens[i].cont == "union" {
            nbEnclavers = 0
            if tokens[i+1].cont == "{" {
                i += 2
                nbEnclavers = 1
            } else if tokens[i+2].cont == "{" {
                i += 3
                nbEnclavers = 1
            } else {
                i++
            }
            tpCons = consumeCType(tokens, i)
            i = tpCons[2]
            if nbEnclavers != 0 {
                for i < len(tokens), i++ {
                    if tokens[i].cont == "(" || tokens[i].cont == "[" || tokens[i].cont == "{" {
                        nbEnclavers++
                    } else if tokens[i].cont == ")" || tokens[i].cont == "]" || tokens[i].cont == "}" {
                        nbEnclavers--
                        if nbEnclavers <= 0 {
                            break
                        }
                    }
                }
            } else {
                i--
            }
            tp = tpCons[0]
        } else if tokens[i].cont == "enum" {
            enumCons = parseCEnum(tokens, i+1)
            if enumCons[0].name == "enum" {
                tp.type = cTypePrim
                tp.name = "int"
            } else {
                tp.type = cTypeEnum
                tp.name = enumCons[0].name
            }
            i = enumCons[1] - 1
        } else if tokens[i].cont == "struct" {
            if tokens[i+1].cont == "{" {
                strctCons = parseCStruct(tokens, i)
                i = strctCons[1] - 1
                tp = strctCons[0]
            } else if i+2 < len(tokens) && tokens[i+2].cont == "{" {
                strctCons = parseCStruct(tokens, i+1)
                i = strctCons[1] - 1
                tp = strctCons[0]
            } else {
                stp = symbols.findStruct(tokens[i+1].cont)
                if stp == null {
                    if i+2 < len(tokens) && tokens[i+2].cont == "*" {
                        tp.type = cTypePrim
                        tp.name = "void"
                    } else {
                        #debug {
                            println("[Debug] could not find struct: "+tokens[i+1].cont+" (at: "+tokens[i+1].getPos()+")")
                        }
                        tp.type = cTypePrim
                        tp.name = "void"
                    }
                } else {
                    tp = stp
                }
                i++
            }

        } else if tp.isShort || tp.isLong {
            tp.type = cTypePrim
            tp.name = "int"
            i--
        } else if tokens[i].cont == "enum" {
            tp.type = cTypeEnum
            tp.name = tokens[i+1].cont
            i++
        } else {
            stp = null
            j=0; for j < len(symbols.types), j++ {
                if symbols.types[j].type == cTypeDef && symbols.types[j].name == tokens[i].cont {
                    stp = symbols.types[j].child
                    break
                }
            }
            if stp == null {
                println(warningMessage+"Unkown type: "+tokens[i].cont+" (at: "+tokens[i].getPos()+")")
                tp.type = cTypePrim
                tp.name = "void"
            } else {
                tp = stp
            }
        }

        i++
        
        for i < len(tokens), i++ {
            if tokens[i].cont != "*" {
                break
            }
            tp = tp.getPtr()
        }

        if tokens[i].cont == "__restrict" {
            i++
        }


        if tokens[i].type == TOKEN_TYPE_VAR {
            name = tokens[i].cont
            i++
        }
    }


    if tokens[i].cont == "[" {
        nbCons = collapseCvalue(tokens, i+1)
        tp = new cType {
            type: cTypeArray
            length: nbCons[0]
            child: tp
            loc: tokens[i].getCLoc()
        }
        i = nbCons[1] + 1
    }

    if tokens[i].cont == "(" {
        if tokens[i+1].cont == "*" {
            fnTpCons = consumeCType(tokens, i)
            fnTpCons[0].ret = tp
            tp = fnTpCons[0]
            name = fnTpCons[1]
            i = fnTpCons[2]
        } else {
            tp = new cType {
                type: cTypeFunc
                ret: tp
                loc: tokens[i].getCLoc()
            }
            currTp = tp
            for i < len(tokens), i++ {
                if tokens[i].cont != "(" && tokens[i].cont != "," {
                    break
                }
                i++

                if tokens[i].cont == ")" {
                    break
                }

                argTpCons = consumeCType(tokens, i)
                currTp.next = new cType {
                    name: argTpCons[1]
                    child: argTpCons[0]
                    loc: tokens[i].getCLoc()
                }
                i = argTpCons[2] - 1
                currTp = currTp.next
            }
            i++
            if tokens[i].cont == "{" {
                if shouldOutpoutC {
                    println(warningMessage + "function \033[33m"+name+"\033[0m() "+tokens[start].getPos()+" is not a definition, you will need to manually translate it to use it.")
                }
                nbBraces = 0
                for i < len(tokens), i++ {
                    if tokens[i].cont == "{" {
                        nbBraces++
                    } else if tokens[i].cont == "}" {
                        nbBraces--
                        if nbBraces == 0 {
                            break
                        }
                    }
                }
                return [null, name, i+1]

            }

            for tokens[i].cont in unusedCattributes {
                nbPar = 0
                i++
                for i < len(tokens), i++ {
                    if tokens[i].cont == "(" {
                        nbPar++
                    } else if tokens[i].cont == ")" {
                        nbPar--
                        if nbPar == 0 {
                            break
                        }
                    }
                }
                i++
            }

            i++
        }
    } else {
        for tokens[i].cont in unusedCattributes {
            nbPar = 0
            i++
            for i < len(tokens), i++ {
                if tokens[i].cont == "(" {
                    nbPar++
                } else if tokens[i].cont == ")" {
                    nbPar--
                    if nbPar == 0 {
                        break
                    }
                }
            }
            i++
        }
    }

    return [tp, name, i]
}

parseCtypedef(tokens []cToken, start uint) uint {
    tpCons = consumeCType(tokens, start)
    tp = new cType{
        name: tpCons[1]
        type: cTypeDef
        child: tpCons[0]
        loc: tokens[start].getCLoc()
    }
    symbols.addType(tp)

    i = tpCons[2]

    if i < len(tokens) && tokens[i].cont == "__attribute__" {
        for i < len(tokens), i++ {
            if tokens[i].cont == ";" {
                break
            }
        }
    }

    if tp.child.type == cTypeStruct {
        if tp.child.name != tp.name {
            tp.child.name = tp.name
            symbols.declareType(tp)
        }
        return i
    }

    symbols.declareType(tp)

    return i
}

parseCunion(tokens []cToken, start uint) uint {
    tpCons = consumeCType(tokens, start + 2)
    tp = new cType{
        name: tokens[start].cont
        type: cTypeDef
        child: tpCons[0]
        loc: tokens[start].getCLoc()
    }
    
    i = tpCons[2]
    nbEnclavers = 1
    for i < len(tokens), i++ {
        if tokens[i].cont == "(" || tokens[i].cont == "[" || tokens[i].cont == "{" {
            nbEnclavers++
        } else if tokens[i].cont == ")" || tokens[i].cont == "]" || tokens[i].cont == "}" {
            nbEnclavers--
            if nbEnclavers <= 0 {
                break
            }
        }
    }
    i++


    symbols.addType(tp)


    if i < len(tokens) && tokens[i].cont == "__attribute__" {
        for i < len(tokens), i++ {
            if tokens[i].cont == ";" {
                break
            }
        }
    }

    return i
}

parseCEnum(tokens []cToken, start uint) [cEnum*, uint] {
    enum = new cEnum {
        loc: tokens[start].getCLoc()
    }

    i = start+1
    if tokens[start].cont == "{" {
        enum.name = "enum"
        i = start
    } else {
        enum.name = tokens[start].cont
    }



    for i < len(tokens), i++ {
        if tokens[i].cont != "{" && tokens[i].cont != "," {
            break
        }
        i++

        if tokens[i].cont == "}" {
            break
        }

        enum.labels[len(enum.labels)] = cEnumLabel {
            name: tokens[i].cont
            val: uintToStr(len(enum.labels))
        }

        if i+2 < len(tokens) && tokens[i+1].cont == "=" {
            enum.labels[len(enum.labels)-1].val = tokens[i+2].cont
            i += 2
        }
    }

    symbols.addEnum(enum)

    symbols.types[len(symbols.types)] = new cType {
        name: enum.name
        type: cTypeEnum
        loc: tokens[start].getCLoc()
    }

    return [enum, i+1]
}

parseCStruct(tokens []cToken, start uint) [cType*, uint] {
    strct = new cType {
        name: tokens[start].cont
        type: cTypeStruct
        child: new cType {}
        loc: tokens[start].getCLoc()
    }

    i = start + 1
    if tokens[start].cont != "struct" {
        symbols.addType(strct)


        if tokens[i].cont == ";" {
            strct.isDeclared = false
            symbols.declareType(strct)
            return [strct, i]
        }
    }

    currTp = strct.child
    for i < len(tokens), i++ {
        if tokens[i].cont != "{" && tokens[i].cont != ";" {
            break
        }
        i++

        if tokens[i].cont == "}" {
            break
        }

        fieldCons = consumeCType(tokens, i)
        i = fieldCons[2] - 1

        currTp.next = new cType {
            name: fieldCons[1]
            child: fieldCons[0]
        }
        currTp = currTp.next

        for i+1 < len(tokens) && tokens[i+1].cont == ",", i += 2 {
            currTp.next = new cType {
                name: tokens[i+2].cont
                child: fieldCons[0]
            }
            currTp = currTp.next
        }
    }

    if tokens[start].cont != "struct" {
        symbols.declareType(strct)
    }


    return [strct, i+1]
}

parseCFile(bahTokens []bahToken, baseDir str) {


    currCPos = [0, ""]
    currPosOffset = 0
    tokens = []cToken
    shouldOutpoutC = true

    i=0; for i < len(bahTokens), i++ {
        if bahTokens[i].cont == "#" {
            start = i
            for i < len(bahTokens), i++ {
                if bahTokens[i].line != bahTokens[start].line {
                    break
                }
            }
            if i != len(bahTokens) && start+2 < len(bahTokens) && bahTokens[start+1].type == TOKEN_TYPE_INT {
                currPosOffset = bahTokens[start+1].line + 1
                currCPos[0] = strToInt(bahTokens[start+1].cont)
                currCPos[1] = bahTokens[start+2].cont[1:len(bahTokens[start+2].cont)-1]

                shouldOutpoutC = isInside(baseDir, currCPos[1])
            }
        }

        ct = cToken{
            realLine: currCPos[0]
            realFile: currCPos[1]
            shouldOutput: shouldOutpoutC
        }
        memcpy(&ct, &bahTokens[i], sizeof(bahToken))

        if ct.type == TOKEN_TYPE_KEYWORD {
            ct.type = TOKEN_TYPE_VAR
        }

        ct.realLine += ct.line - currPosOffset

        tokens[len(tokens)] = ct
    }

    i=0; for i < len(tokens), i++ {
        shouldOutpoutC = tokens[i].shouldOutput

        start = i
        if tokens[start].cont == "enum" {
            i = parseCEnum(tokens, start+1)[1]
        } else if tokens[start].cont == "struct" {
            i = parseCStruct(tokens, start+1)[1]
        } else if tokens[start].cont == "union" {
            i = parseCunion(tokens, start+1)
        } else if tokens[start].cont == "typedef" {
            i = parseCtypedef(tokens, start+1)
        } else if tokens[start].cont[0] == '#' {
            startLine = tokens[start].line
            i++
            for i < len(tokens), i++ {
                if tokens[i].line != startLine {
                    break
                }
            }
            i--
        } else {

            tp = consumeCType(tokens, start)

            if tp[0] == null {
                i = tp[2] - 1
                continue
            }

            if tp[0].type == cTypeFunc {
                symbols.addFunc(new cFunc {
                    name: tp[1]
                    type: tp[0]
                    loc: tokens[start].getCLoc()
                })
                i = tp[2] - 1
                continue
            } else {
                i = tp[2]
                continue
            }
        }
    }

    println("\n\033[1;32mDone!\033[0m")
    if onlyWarnings == false {
        println(intToStr(len(symbols.types))+" types.")
        println(intToStr(len(symbols.funcs))+" functions.")
        println(intToStr(len(symbols.vars))+" variables.")
        println(intToStr(len(symbols.enums))+" enums.")
    }
}